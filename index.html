<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorador de Paralelismo a Nivel de Chip (CLP)</title>
    <link href="./site.css" rel="stylesheet">
  </head>
</head>
<body>

    <div class="container">
        <h1>游 Explorador de Paralelismo a Nivel de Chip (CLP)</h1>

        <nav>
            <button class="tablink" onclick="openTab(event, 'Introduccion')" id="defaultOpen">Introducci칩n</button>
            <button class="tablink" onclick="openTab(event, 'TiposParalelismo')">Tipos de Paralelismo (ILP, TLP, DLP)</button>
            <button class="tablink" onclick="openTab(event, 'Arquitecturas')">Arquitecturas Clave</button>
            <button class="tablink" onclick="openTab(event, 'Simulador')">Simulador Conceptual</button>
            <button class="tablink" onclick="openTab(event, 'Evaluacion')">Autoevaluaci칩n</button>
        </nav>

        <div id="Introduccion" class="tabcontent">
            <h2>Bienvenida al Paralelismo a Nivel de Chip (CLP)</h2>
            <p>El **Paralelismo a Nivel de Chip (Chip-Level Parallelism - CLP)** se refiere a las t칠cnicas utilizadas dentro de un solo microprocesador (chip) para ejecutar m칰ltiples tareas o instrucciones simult치neamente. </p>
            <p>Durante d칠cadas, el rendimiento de los procesadores aument칩 principalmente incrementando la velocidad del reloj (frecuencia, medida en GHz). Sin embargo, alrededor de 2005, esto se volvi칩 insostenible debido a dos barreras principales:</p>
            <ul>
                <li><strong>El Muro del Consumo de Energ칤a (Power Wall):</strong> A mayor frecuencia, mayor consumo de energ칤a y, por lo tanto, 춰m치s calor! Se volvi칩 imposible enfriar los chips de manera eficiente.</li>
                <li><strong>El Muro de la Complejidad (Complexity Wall):</strong> Dise침ar procesadores de un solo n칰cleo cada vez m치s r치pidos y complejos (como los superescalares profundos) comenz칩 a dar rendimientos decrecientes.</li>
            </ul>
            <p>La soluci칩n fue cambiar el enfoque: en lugar de hacer *una* cosa muy r치pida, 쯣or qu칠 no hacer *muchas* cosas a la vez a una velocidad razonable? As칤 naci칩 la era del CLP.</p>
            
            <h3>Implicancias del CLP</h3>
            <ul>
                <li><strong>Rendimiento:</strong> El rendimiento ya no depende de la velocidad del reloj, sino de cu치ntas tareas paralelas puede manejar el chip. Esto es crucial para software moderno (servidores web, IA, videojuegos).</li>
                <li><strong>Dise침o:</strong> Los dise침adores de chips ahora se centran en c칩mo integrar m칰ltiples "cerebros" (n칰cleos) en un chip, c칩mo se comunican entre s칤 y c칩mo comparten recursos (como la memoria cach칠).</li>
                <li><strong>Eficiencia (Rendimiento por Vatio):</strong> Varios n칰cleos m치s simples y lentos suelen ser mucho m치s eficientes energ칠ticamente que un solo n칰cleo monol칤tico y ultra-r치pido para tareas paralelas.</li>
            </ul>
        </div>

        <div id="TiposParalelismo" class="tabcontent">
            <h2>Identificando el Paralelismo (ILP, TLP, DLP)</h2>
            <p>En las arquitecturas modernas, el CLP se manifiesta explotando diferentes tipos de paralelismo. Los tres principales son:</p>
            
            <div class="img-placeholder"></div>
            <br>
            
            <div class="grid-container">
                <div class="grid-item">
                    <h3>1. Paralelismo a Nivel de Instrucci칩n (ILP)</h3>
                    <p><strong>쯈u칠 es?</strong> Es la capacidad de ejecutar m칰ltiples instrucciones *del mismo programa o hilo* al mismo tiempo.</p>
                    <p><strong>Analog칤a:</strong> Una l칤nea de ensamblaje de f치brica (Pipelining) o una f치brica con varias l칤neas de ensamblaje (Superscalar) trabajando en *un solo producto*.</p>
                    <p><strong>T칠cnicas Clave:</strong></p>
                    <ul>
                        <li><strong>Pipelining (Segmentaci칩n):</strong> Se solapan las etapas de ejecuci칩n de diferentes instrucciones (Fetch, Decode, Execute, Writeback).</li>
                        <li><strong>Ejecuci칩n Superescalar:</strong> El procesador tiene m칰ltiples unidades de ejecuci칩n (ej. 2 ALUs, 1 FPU) y puede despachar m치s de una instrucci칩n por ciclo de reloj.</li>
                        <li><strong>Ejecuci칩n Fuera de Orden (OoOE):</strong> Reordena las instrucciones para mantener las unidades de ejecuci칩n ocupadas, incluso si una instrucci칩n est치 bloqueada (ej. esperando datos de memoria).</li>
                    </ul>
                </div>

                <div class="grid-item">
                    <h3>2. Paralelismo a Nivel de Hilo (TLP)</h3>
                    <p><strong>쯈u칠 es?</strong> Es la capacidad de ejecutar instrucciones de *diferentes hilos o programas* de forma concurrente.</p>
                    <p><strong>Analog칤a:</strong> Una cocina con un chef (n칰cleo) que cambia r치pidamente entre dos recetas (hilos) para aprovechar el tiempo mientras una se cocina (Multithreading), O una cocina con dos chefs (n칰cleos), cada uno con su propia receta (Multi-core).</p>
                    <p><strong>T칠cnicas Clave:</strong></p>
                    <ul>
                        <li><strong>Multithreading (Simult치neo - SMT):</strong> Un solo n칰cleo f칤sico finge ser dos (o m치s) n칰cleos l칩gicos para el sistema operativo. Comparte las unidades de ejecuci칩n entre hilos en el *mismo ciclo de reloj*. (Ej. Hyper-Threading de Intel).</li>
                        <li><strong>Multi-core:</strong> El chip contiene m칰ltiples n칰cleos de procesamiento (CPUs) completos e independientes. Esta es la forma m치s expl칤cita de TLP.</li>
                    </ul>
                </div>

                <div class="grid-item">
                    <h3>3. Paralelismo a Nivel de Datos (DLP)</h3>
                    <p><strong>쯈u칠 es?</strong> Es la capacidad de aplicar *la misma operaci칩n* a *m칰ltiples elementos de datos* simult치neamente.</p>
                    <p><strong>Analog칤a:</strong> Un sello de goma grande (operaci칩n) que marca una fila completa de 10 sobres (datos) con un solo movimiento, en lugar de sellar uno por uno.</p>
                    <p><strong>T칠cnicas Clave:</strong></p>
                    <ul>
                        <li><strong>Instrucciones SIMD (Single Instruction, Multiple Data):</strong> El procesador tiene registros e instrucciones especiales (ej. SSE, AVX) que pueden sumar 4, 8 o m치s pares de n칰meros a la vez.</li>
                        <li><strong>Procesadores Vectoriales / GPUs:</strong> Llevan esto al extremo, con miles de "n칰cleos" simples dise침ados para hacer la misma operaci칩n matem치tica en grandes conjuntos de datos (ideal para gr치ficos, IA).</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div id="Arquitecturas" class="tabcontent">
            <h2>Arquitecturas Clave del CLP</h2>
            <p>Estos son los bloques de construcci칩n fundamentales que implementan los tipos de paralelismo que vimos.</p>

            <article>
                <h3>Ejecuci칩n Superescalar (Explotando ILP)</h3>
                <p>Un procesador superescalar tiene m칰ltiples unidades de ejecuci칩n (pipelines) y puede buscar, decodificar y despachar *m칰ltiples instrucciones por ciclo de reloj*. Es la base de casi todos los procesadores modernos (Intel Core, AMD Ryzen, Apple M-series).</p>
                <ul>
                    <li><strong>Concepto:</strong> Explotar ILP.</li>
                    <li><strong>C칩mo:</strong> Duplicar el hardware interno (ALUs, FPUs, puertos de cach칠).</li>
                    <li><strong>Desaf칤o:</strong> Encontrar suficientes instrucciones independientes en un solo hilo. La ejecuci칩n fuera de orden (OoOE) es vital para esto.</li>
                </ul>
                <div class="img-placeholder"></div>
            </article>

            <hr>

            <article>
                <h3>Multihilo o Multithreading (Explotando TLP)</h3>
                <p>Esta t칠cnica permite que un solo n칰cleo de procesador maneje m칰ltiples hilos. Su objetivo principal es *ocultar la latencia* (especialmente las esperas a la memoria RAM, que son muy lentas).</p>
                <ul>
                    <li><strong>Multithreading de Grano Grueso:</strong> El n칰cleo ejecuta un hilo hasta que este se bloquea (ej. fallo de cach칠). Entonces, vac칤a su pipeline y cambia a otro hilo. Pierde algunos ciclos en el cambio.</li>
                    <li><strong>Multithreading Simult치neo (SMT):</strong> El n칰cleo puede tomar instrucciones de *dos o m치s hilos* y ejecutarlas en el *mismo ciclo* si usan unidades de ejecuci칩n diferentes. Para el SO, un n칰cleo f칤sico aparece como dos (o m치s) n칰cleos l칩gicos. (Ej. Hyper-Threading).</li>
                </ul>
                <div class="img-placeholder"></div>
            </article>

            <hr>

            <article>
                <h3>M칰ltiples N칰cleos (Multi-core) (Explotando TLP)</h3>
                <p>Esta es la forma m치s visible de CLP. En lugar de hacer un solo n칰cleo m치s complejo, el chip integra dos, cuatro, ocho o m치s n칰cleos (CPUs) completos. Cada n칰cleo es t칤picamente superescalar y puede tener su propio SMT.</p>
                <ul>
                    <li><strong>Concepto:</strong> Replicar procesadores enteros dentro del mismo chip.</li>
                    <li><strong>C칩mo:</strong> Cada n칰cleo tiene su propia L1/L2 cach칠 (generalmente), y comparten una cach칠 L3 m치s grande y el acceso a la RAM.</li>
                    <li><strong>Desaf칤o:</strong> El software debe estar expl칤citamente paralelizado (dividido en hilos) para aprovechar los m칰ltiples n칰cleos. El sistema operativo se encarga de asignar hilos a los n칰cleos.</li>
                </ul>
                <div class="img-placeholder"></div>
            </article>
        </div>

        <div id="Simulador" class="tabcontent">
            <h2>Simulador Conceptual de Carga de Trabajo</h2>
            <p>Selecciona una arquitectura y una carga de trabajo para ver una simulaci칩n visual de c칩mo se procesan las tareas. Cada "Tarea" representa una unidad de trabajo, y cada "Ciclo" es una unidad de tiempo.</p>

            <div id="sim-controls">
                <label for="workload">Carga de Trabajo (N췈 de Tareas): </label>
                <input type="number" id="workload" value="16" min="4" max="64" step="4">
                
                <label for="architecture">Seleccionar Arquitectura: </label>
                <select id="architecture">
                    <option value="single">Single-Core (Scalar)</option>
                    <option value="superscalar">Superscalar (2-wide)</option>
                    <option value="multicore">Multi-Core (4 n칰cleos)</option>
                    <option value="multicore-smt">Multi-Core (2 n칰cleos) + SMT (2 hilos/n칰cleo)</option>
                </select>
                
                <button onclick="runSimulation()">Ejecutar Simulaci칩n</button>
            </div>

            <div id="sim-output">
                </div>
            <div id="sim-results">
                Selecciona las opciones y presiona "Ejecutar Simulaci칩n".
            </div>
        </div>

        <div id="Evaluacion" class="tabcontent">
            <h2>Autoevaluaci칩n R치pida</h2>
            <p>Pon a prueba tu comprensi칩n de los conceptos clave.</p>

            <div class="quiz-question">
                <p>1. 쯈u칠 tipo principal de paralelismo intenta explotar una arquitectura **superescalar**?</p>
                <div class="quiz-options">
                    <label><input type="radio" name="q1" value="ilp"> ILP (Paralelismo a Nivel de Instrucci칩n)</label>
                    <label><input type="radio" name="q1" value="tlp"> TLP (Paralelismo a Nivel de Hilo)</label>
                    <label><input type="radio" name="q1" value="dlp"> DLP (Paralelismo a Nivel de Datos)</label>
                </div>
            </div>

            <div class="quiz-question">
                <p>2. 쮺u치l es la diferencia clave entre **Multi-core** y **Multithreading (SMT)**?</p>
                <div class="quiz-options">
                    <label><input type="radio" name="q2" value="a"> SMT usa un n칰cleo para ejecutar muchos hilos, Multi-core usa muchos n칰cleos para ejecutar un hilo.</label>
                    <label><input type="radio" name="q2" value="b"> Multi-core replica n칰cleos f칤sicos completos, SMT comparte los recursos de un solo n칰cleo entre hilos l칩gicos.</label>
                    <label><input type="radio" name="q2" value="c"> No hay diferencia, son sin칩nimos.</label>
                </div>
            </div>

            <div class="quiz-question">
                <p>3. Un procesador que ejecuta una instrucci칩n <code>ADD</code> en 8 pares de n칰meros a la vez est치 usando...</p>
                <div class="quiz-options">
                    <label><input type="radio" name="q3" value="ilp"> ILP (Paralelismo a Nivel de Instrucci칩n)</label>
                    <label><input type="radio" name="q3" value="tlp"> TLP (Paralelismo a Nivel de Hilo)</label>
                    <label><input type="radio" name="q3" value="dlp"> DLP (Paralelismo a Nivel de Datos)</label>
                </div>
            </div>

            <button onclick="checkQuiz()">Corregir Examen</button>
            <div id="quiz-feedback"></div>

        </div>

    </div>

    <script>
        // --- L칩gica de Pesta침as ---
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablink");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
        // Abrir la primera pesta침a por defecto
        document.getElementById("defaultOpen").click();

        // --- L칩gica del Simulador ---
        function runSimulation() {
            const workload = parseInt(document.getElementById('workload').value);
            const arch = document.getElementById('architecture').value;
            const output = document.getElementById('sim-output');
            const results = document.getElementById('sim-results');
            
            output.innerHTML = ''; // Limpiar simulaci칩n anterior
            let cycles = 0;
            let totalTasks = workload;
            let tasksDone = 0;
            
            let coreHtml = '';
            let tasksPerCycle = 0;
            let numCores = 0;

            switch (arch) {
                case 'single':
                    numCores = 1;
                    tasksPerCycle = 1;
                    cycles = Math.ceil(totalTasks / tasksPerCycle);
                    coreHtml = createCoreBars(numCores, totalTasks, tasksPerCycle, 'task-bar');
                    break;
                case 'superscalar':
                    numCores = 1;
                    tasksPerCycle = 2; // 2-wide
                    cycles = Math.ceil(totalTasks / tasksPerCycle);
                    coreHtml = createCoreBars(numCores, totalTasks, tasksPerCycle, 'task-bar-superscalar');
                    break;
                case 'multicore':
                    numCores = 4;
                    tasksPerCycle = 1; // 1 tarea por n칰cleo
                    cycles = Math.ceil(totalTasks / (numCores * tasksPerCycle));
                    coreHtml = createCoreBars(numCores, totalTasks, tasksPerCycle, 'task-bar-multicore');
                    break;
                case 'multicore-smt':
                    numCores = 2; // 2 n칰cleos f칤sicos
                    tasksPerCycle = 2; // 2 hilos por n칰cleo = 2 tareas por n칰cleo
                    cycles = Math.ceil(totalTasks / (numCores * tasksPerCycle));
                    coreHtml = createCoreBars(numCores, totalTasks, tasksPerCycle, 'task-bar-multicore');
                    break;
            }

            output.innerHTML = coreHtml;
            results.innerHTML = `Arquitectura: ${arch} | Tareas: ${totalTasks} | <strong>Ciclos Totales: ${cycles}</strong>`;

            // Animar las barras
            const bars = document.querySelectorAll('.task-bar-wrapper');
            let taskCounter = 0;
            let currentCycle = 0;

            function animateCycle() {
                if (taskCounter >= totalTasks) return;
                
                currentCycle++;
                results.innerHTML = `Arquitectura: ${arch} | Tareas: ${totalTasks} | Ciclo actual: ${currentCycle} | <strong>Ciclos Totales (Estimados): ${cycles}</strong>`;

                let tasksThisCycle = 0;
                if (arch === 'single') tasksThisCycle = 1;
                if (arch === 'superscalar') tasksThisCycle = 2;
                if (arch === 'multicore') tasksThisCycle = 4;
                if (arch === 'multicore-smt') tasksThisCycle = 4; // 2 n칰cleos * 2 hilos

                for (let i = 0; i < tasksThisCycle; i++) {
                    if (taskCounter < totalTasks) {
                        const coreIndex = taskCounter % numCores;
                        const bar = bars[coreIndex].querySelector('.task-bar');
                        const currentWidth = parseFloat(bar.style.width) || 0;
                        const taskWidth = (1 / (totalTasks / numCores)) * 100;
                        
                        // Para superscalar, la barra es 칰nica
                        if (arch === 'superscalar') {
                            const barSuper = bars[0].querySelector('.task-bar');
                            const superTaskWidth = (1 / totalTasks) * 100;
                            barSuper.style.width = `${(taskCounter + 1) * superTaskWidth}%`;
                        } 
                        // Para single core, la barra es 칰nica
                        else if (arch === 'single') {
                            const barSingle = bars[0].querySelector('.task-bar');
                            const singleTaskWidth = (1 / totalTasks) * 100;
                            barSingle.style.width = `${(taskCounter + 1) * singleTaskWidth}%`;
                        }
                        // Para multi-core y SMT
                        else {
                            const coreTaskCount = Math.floor(taskCounter / numCores) + 1;
                            const coreTotalTasks = Math.ceil(totalTasks / numCores);
                            bar.style.width = `${(coreTaskCount / coreTotalTasks) * 100}%`;
                        }
                        taskCounter++;
                    }
                }
                
                if (taskCounter < totalTasks) {
                    setTimeout(animateCycle, 300); // Siguiente ciclo
                } else {
                     results.innerHTML = `춰Completado! | Arquitectura: ${arch} | Tareas: ${totalTasks} | <strong>Ciclos Finales: ${currentCycle}</strong>`;
                }
            }
            
            // Iniciar animaci칩n
            animateCycle();
        }

        function createCoreBars(numCores, totalTasks, tasksPerCycle, barClass) {
            let html = '';
            // Caso especial para Superescalar (1 n칰cleo, M칰ltiples tareas por ciclo)
            if (numCores === 1) {
                let label = (tasksPerCycle > 1) ? `N칰cleo Superescalar (x${tasksPerCycle})` : 'N칰cleo 칔nico';
                html += `
                    <div class="core-container task-bar-wrapper">
                        <span class="core-label">${label}:</span>
                        <div class="task-bar ${barClass}" style="width: 0%;" title="Capacidad: ${totalTasks} tareas"></div>
                    </div>`;
            } else {
            // Caso Multi-core
                for (let i = 0; i < numCores; i++) {
                    let label = `N칰cleo ${i + 1}`;
                    if(tasksPerCycle > 1) {
                        label += ` (SMT x${tasksPerCycle})`;
                    }
                    html += `
                        <div class="core-container task-bar-wrapper">
                            <span class="core-label">${label}:</span>
                            <div class="task-bar ${barClass}" style="width: 0%;" title="Capacidad: ${Math.ceil(totalTasks/numCores)} tareas"></div>
                        </div>`;
                }
            }
            return html;
        }

        // --- L칩gica del Cuestionario ---
        function checkQuiz() {
            const answers = {
                q1: 'ilp',
                q2: 'b',
                q3: 'dlp'
            };

            let score = 0;
            let total = Object.keys(answers).length;
            let feedback = '';

            for (let q in answers) {
                const selected = document.querySelector(`input[name="${q}"]:checked`);
                if (selected) {
                    if (selected.value === answers[q]) {
                        score++;
                        feedback += `<p><strong>Pregunta ${q.slice(1)}:</strong> Correcta. 춰Bien hecho!</p>`;
                    } else {
                        feedback += `<p><strong>Pregunta ${q.slice(1)}:</strong> Incorrecta. La respuesta correcta era sobre ${getCorrectAnswerText(q, answers[q])}.</p>`;
                    }
                } else {
                    feedback += `<p><strong>Pregunta ${q.slice(1)}:</strong> No respondida.</p>`;
                }
            }

            const feedbackEl = document.getElementById('quiz-feedback');
            feedbackEl.innerHTML = `<h3>Resultado: ${score} de ${total} correctas</h3>` + feedback;
            feedbackEl.style.display = 'block';

            if (score === total) {
                feedbackEl.className = 'correct';
            } else {
                feedbackEl.className = 'incorrect';
            }
        }

        function getCorrectAnswerText(q, val) {
            if (q === 'q1') return 'ILP';
            if (q === 'q2') return 'la replicaci칩n de n칰cleos (Multi-core) vs la compartici칩n de recursos (SMT)';
            if (q === 'q3') return 'DLP (SIMD)';
            return '';
        }

    </script>

</body>
</html>
